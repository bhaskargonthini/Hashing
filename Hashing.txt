HASHING

In hashing search, insert and delete can be done in O(1) on average.
Hashing will be the ebst choice than other data structures like arrays,BST etc...
Hashing is the best choice only if we want to use operations like search, insert and delete opearations only.
But not useful for:
  - finding the closest value.
  -sorted data
  -prefix searching
Applications of Hashing: second most used data structure.
  --Dictionaries
  --Database indexing
  --cryptography
  --caches
  --symbol tables in compilers/interpreters
  --routers
  --getting data from databases etc....
The problem with the arrays data structure or direct address table is it cant handle large inpit vaalues like phone numbers which contains 10 digit numbers and also floating
pount numbers,

Hashing INTRO:
How hash funtion works?
-- should always map a large key to same small key
-- should generate values from 0 to m-1
-- should be fast, O(1) for integers and O(len) for string of length len
-- should uniformly distribute learge keys into hash table slots.

Example of hash functions:
1) h(large_key) = large_key%m
2) for strings, weighted sum:
    str[] = "abcd"
    (str[0]*x^0+str[1]*x^1+str[2]*x^2+str[3]*x^3)%m
 3) universal hashing
 
 Here we are doing modulus of a specific number while allocating the numbers to keys, so there might be cases where one value might be repeated when doing the modulus
 function, so there will be a problem of collision. So we can talk about collision handlinbg.
 ex: 132%10 = 2 and also 142%10 = 2 so these two values might be collided while alloting to the hash table
 COLLISION HANDLING:
 If we know the keys in advance, then we can find the perfect hasing function.
 If we do not know the keys, then we use one of the following
  -- chaining
  --Open addressing
      -- Linear probing
      -- Quadratic probing
      -- Double hashing.
CHAINING:
Chaining will works with array of llinked lists, where if there is collision in the keys, then it will form an extra node with the existing one and start implementing the 
linked list from that node. Eg...
Hash(key) = key%7
keys = {50,21,58,17,15,49,56,22,23,25}

0 -> 21 ->49 ->56
1 -> 50 ->15 ->22
2 -> 58 ->23
3 -> 17
4 -> 25
5
6

IMPLEMENTATION OF CHAINING:
// C++ program to demonstrate implementation of our 
// own hash table with chaining for collision detection 
#include<bits/stdc++.h>
using namespace std;

struct MyHash
{
    int BUCKET;
    list<int> *table;
    MyHash(int b)
    {
        BUCKET = b;
        table = new list<int>[BUCKET];
    }
    void insert(int k)
    {
        int i = k % BUCKET;
        table[i].push_back(k);
    }
    bool search(int k)
    {
        int i = k % BUCKET;
        for (auto x : table[i])
           if (x == k)
              return true;
        return false;      
    }
    void remove(int k)
    {
        int i = k % BUCKET;
        table[i].remove(k);
    }
};

	// Driver method to test Map class 
	int main() 
	{ 
	    MyHash mh(7);
	    mh.insert(10);
	    mh.insert(20);
	    mh.insert(15);
	    mh.insert(7);
	    cout << mh.search(10) << endl;
	    mh.remove(15);
	    cout << mh.search(15);
	} 
another way:
vector<vector<int>> separateChaining(int hashSize,int arr[],int sizeOfArray)
    {
       //Your code here
        vector<vector<int>> ans(hashSize);
       for(int i=0;i<sizeOfArray;i++){
           ans[arr[i]%hashSize].push_back(arr[i]);
       }
       return ans;
       
    }
    
    -------------------------------------------------------------------------------------------------------------------------------------------------------------
  OPEN ADDRESSING:
  
  No of slots in hash table >= no of keys to be inserted.
  Liner probing:
    Linearly search for next empty slot when there is a collision.
    
  Implementation of open addressing:
    
    #include<bits/stdc++.h>
using namespace std;

struct MyHash
{
    int *arr;
    int cap,size;
    
    MyHash(int c)
    {
        cap=c;
        size=0;
        arr=new int[cap];
        for(int i=0;i<cap;i++)
            arr[i]=-1;
    }
    
    int hash(int key){
        return key%cap;
    }
    bool insert(int key)
    {
        if(size==cap)
            return false;
        int i=hash(key);
        while(arr[i]!=-1 && arr[i]!=-2 && arr[i]!=key)
            i=(i+1)%cap;
        if(arr[i]==key)
            return false;
        else{
            arr[i]=key;
            size++;
            return true;
        }
    }
    bool search(int key)
    {
        int h=hash(key);
        int i=h;
        while(arr[i]!=-1){
            if(arr[i]==key)
                return true;
            i=(i+1)%cap;
            if(i==h)
                return false;
        }
        return false;
    }
    bool erase(int key)
    {   
        int h=hash(key);
        int i=h;
        while(arr[i]!=-1){
            if(arr[i]==key){
                arr[i]=-2;
                return true;
            }
            i=(i+1)%cap;
            if(i==h)
                return false;
        }
        return false;
    }
};

	int main() 
	{ 
	    MyHash mh(7);
	    mh.insert(49);
	    mh.insert(56);
	    mh.insert(72);
	    if(mh.search(56)==true)
	        cout<<"Yes"<<endl;
	    else
	        cout<<"No"<<endl;
	    mh.erase(56);
	    if(mh.search(56)==true)
	        cout<<"Yes"<<endl;
	    else
	        cout<<"No"<<endl;
	} 
----------------------------------------------------------------------------------------------------------------------------------------------------------------

 
