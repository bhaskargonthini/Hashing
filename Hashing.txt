HASHING

In hashing search, insert and delete can be done in O(1) on average.
Hashing will be the ebst choice than other data structures like arrays,BST etc...
Hashing is the best choice only if we want to use operations like search, insert and delete opearations only.
But not useful for:
  - finding the closest value.
  -sorted data
  -prefix searching
Applications of Hashing: second most used data structure.
  --Dictionaries
  --Database indexing
  --cryptography
  --caches
  --symbol tables in compilers/interpreters
  --routers
  --getting data from databases etc....
The problem with the arrays data structure or direct address table is it cant handle large inpit vaalues like phone numbers which contains 10 digit numbers and also floating
pount numbers,

Hashing INTRO:
How hash funtion works?
-- should always map a large key to same small key
-- should generate values from 0 to m-1
-- should be fast, O(1) for integers and O(len) for string of length len
-- should uniformly distribute learge keys into hash table slots.

Example of hash functions:
1) h(large_key) = large_key%m
2) for strings, weighted sum:
    str[] = "abcd"
    (str[0]*x^0+str[1]*x^1+str[2]*x^2+str[3]*x^3)%m
 3) universal hashing
 
 Here we are doing modulus of a specific number while allocating the numbers to keys, so there might be cases where one value might be repeated when doing the modulus
 function, so there will be a problem of collision. So we can talk about collision handlinbg.
 ex: 132%10 = 2 and also 142%10 = 2 so these two values might be collided while alloting to the hash table
 COLLISION HANDLING:
 If we know the keys in advance, then we can find the perfect hasing function.
 If we do not know the keys, then we use one of the following
  -- chaining
  --Open addressing
      -- Linear probing
      -- Quadratic probing
      -- Double hashing.
CHAINING:
Chaining will works with array of llinked lists, where if there is collision in the keys, then it will form an extra node with the existing one and start implementing the 
linked list from that node. Eg...
Hash(key) = key%7
keys = {50,21,58,17,15,49,56,22,23,25}

0 -> 21 ->49 ->56
1 -> 50 ->15 ->22
2 -> 58 ->23
3 -> 17
4 -> 25
5
6

IMPLEMENTATION OF CHAINING:
// C++ program to demonstrate implementation of our 
// own hash table with chaining for collision detection 
#include<bits/stdc++.h>
using namespace std;

struct MyHash
{
    int BUCKET;
    list<int> *table;
    MyHash(int b)
    {
        BUCKET = b;
        table = new list<int>[BUCKET];
    }
    void insert(int k)
    {
        int i = k % BUCKET;
        table[i].push_back(k);
    }
    bool search(int k)
    {
        int i = k % BUCKET;
        for (auto x : table[i])
           if (x == k)
              return true;
        return false;      
    }
    void remove(int k)
    {
        int i = k % BUCKET;
        table[i].remove(k);
    }
};

	// Driver method to test Map class 
	int main() 
	{ 
	    MyHash mh(7);
	    mh.insert(10);
	    mh.insert(20);
	    mh.insert(15);
	    mh.insert(7);
	    cout << mh.search(10) << endl;
	    mh.remove(15);
	    cout << mh.search(15);
	} 
another way:
vector<vector<int>> separateChaining(int hashSize,int arr[],int sizeOfArray)
    {
       //Your code here
        vector<vector<int>> ans(hashSize);
       for(int i=0;i<sizeOfArray;i++){
           ans[arr[i]%hashSize].push_back(arr[i]);
       }
       return ans;
       
    }
    
    -------------------------------------------------------------------------------------------------------------------------------------------------------------
  OPEN ADDRESSING:
  
  No of slots in hash table >= no of keys to be inserted.
  Liner probing:
    Linearly search for next empty slot when there is a collision.
    
  Implementation of open addressing:
    
    #include<bits/stdc++.h>
using namespace std;

struct MyHash
{
    int *arr;
    int cap,size;
    
    MyHash(int c)
    {
        cap=c;
        size=0;
        arr=new int[cap];
        for(int i=0;i<cap;i++)
            arr[i]=-1;
    }
    
    int hash(int key){
        return key%cap;
    }
    bool insert(int key)
    {
        if(size==cap)
            return false;
        int i=hash(key);
        while(arr[i]!=-1 && arr[i]!=-2 && arr[i]!=key)
            i=(i+1)%cap;
        if(arr[i]==key)
            return false;
        else{
            arr[i]=key;
            size++;
            return true;
        }
    }
    bool search(int key)
    {
        int h=hash(key);
        int i=h;
        while(arr[i]!=-1){
            if(arr[i]==key)
                return true;
            i=(i+1)%cap;
            if(i==h)
                return false;
        }
        return false;
    }
    bool erase(int key)
    {   
        int h=hash(key);
        int i=h;
        while(arr[i]!=-1){
            if(arr[i]==key){
                arr[i]=-2;
                return true;
            }
            i=(i+1)%cap;
            if(i==h)
                return false;
        }
        return false;
    }
};

	int main() 
	{ 
	    MyHash mh(7);
	    mh.insert(49);
	    mh.insert(56);
	    mh.insert(72);
	    if(mh.search(56)==true)
	        cout<<"Yes"<<endl;
	    else
	        cout<<"No"<<endl;
	    mh.erase(56);
	    if(mh.search(56)==true)
	        cout<<"Yes"<<endl;
	    else
	        cout<<"No"<<endl;
	} 
----------------------------------------------------------------------------------------------------------------------------------------------------------------
UNORDERED SET IN STL: there cannot be duplicate keys in unordered set.

unlike set, unordered set has different functionalities. If we insert elements in unordered set, when we print the ouput the output sequences may differ in different compilers. There is no specific order in which these elements are stored in the unordered set.
Different functions of unordered set are:
insert() - insert an element into the set.
begin() - returns the iterator of first element
end()- return an ietrator beyond the end element.
size() - gives the size of the set
clear() - empties the set
find() - finds the element in the set. If present it return the address of that element. Else it return variableName.end().
count() - returns either 1 or 0 if elements is present or not. similar to find but it returns 1 or 0.
Erase() - used to remove a single item or range of items in the set.
all functions have O(1) time complexity in an average.
#include <bits/stdc++.h> 
using namespace std; 

int main(){
    
    unordered_set <int> s;
    s.insert(10);
    s.insert(5);
    s.insert(15);
    s.insert(20);
    for(int x: s)
        cout<<x<<" ";
        
    cout<<endl;
    for(auto it=s.begin();it!=s.end();it++)
        cout<<*it<<" ";
    cout<<endl;
    cout<<s.size()<<endl;
    s.clear();
    cout<<s.size()<<endl;
    
    s.insert(10);
    s.insert(5);
    s.insert(15);
    s.insert(20);
    cout<<s.size()<<endl;
    
    if(s.find(15)==s.end())
        cout<<"Not Found";
    else
        cout<<"Found "<<(*s.find(15));
    
    cout<<endl;   
    if(s.count(15))
        cout<<"Found";
    else
        cout<<"Not Found";
    cout<<endl;
    
    cout<<s.size()<<endl;
    s.erase(15);
    cout<<s.size()<<endl;
    auto it=s.find(10);
    s.erase(it);
    cout<<s.size()<<endl;
    
    s.erase(s.begin(),s.end());
        
    return 0;
}

--------------------------------------------------
UNORDERED HASHMAP IN STL:
-- used to store key value pairs.
-- uses hashing
-- no order of keys.

#include <bits/stdc++.h> 
using namespace std; 

int main(){
    
    unordered_map <string,int> m;
    m["gfg"]=20;
    m["ide"]=30;
    m.insert({"courses",15});
    
    if(m.find("ide")!=m.end())
        cout<<"Found";
    else
        cout<<"Not Found ";
    
    cout<<endl;
    
    for(auto it=m.begin();it!=m.end();it++)
        cout<<(it->first)<<" "<<(it->second)<<endl;
    
    if(m.count("ide")>0)
        cout<<"Found";
    else
        cout<<"Not Found";
    cout<<endl;
    
    cout<<m.size()<<endl;
    m.erase("ide");
    m.erase(m.begin());
    cout<<m.size()<<endl;
    m.erase(m.begin(),m.end());
        
    return 0;
}



 
