HASHING

In hashing search, insert and delete can be done in O(1) on average.
Hashing will be the ebst choice than other data structures like arrays,BST etc...
Hashing is the best choice only if we want to use operations like search, insert and delete opearations only.
But not useful for:
  - finding the closest value.
  -sorted data
  -prefix searching
Applications of Hashing: second most used data structure.
  --Dictionaries
  --Database indexing
  --cryptography
  --caches
  --symbol tables in compilers/interpreters
  --routers
  --getting data from databases etc....
The problem with the arrays data structure or direct address table is it cant handle large inpit vaalues like phone numbers which contains 10 digit numbers and also floating
pount numbers,

Hashing INTRO:
How hash funtion works?
-- should always map a large key to same small key
-- should generate values from 0 to m-1
-- should be fast, O(1) for integers and O(len) for string of length len
-- should uniformly distribute learge keys into hash table slots.

Example of hash functions:
1) h(large_key) = large_key%m
2) for strings, weighted sum:
    str[] = "abcd"
    (str[0]*x^0+str[1]*x^1+str[2]*x^2+str[3]*x^3)%m
 3) universal hashing
 
 Here we are doing modulus of a specific number while allocating the numbers to keys, so there might be cases where one value might be repeated when doing the modulus
 function, so there will be a problem of collision. So we can talk about collision handlinbg.
 ex: 132%10 = 2 and also 142%10 = 2 so these two values might be collided while alloting to the hash table
 COLLISION HANDLING:
 If we know the keys in advance, then we can find the perfect hasing function.
 If we do not know the keys, then we use one of the following
  -- chaining
  --Open addressing
      -- Linear probing
      -- Quadratic probing
      -- Double hashing.
CHAINING:
Chaining will works with array of llinked lists, where if there is collision in the keys, then it will form an extra node with the existing one and start implementing the 
linked list from that node. Eg...
Hash(key) = key%7
keys = {50,21,58,17,15,49,56,22,23,25}

0 -> 21 ->49 ->56
1 -> 50 ->15 ->22
2 -> 58 ->23
3 -> 17
4 -> 25
5
6

IMPLEMENTATION OF CHAINING:
// C++ program to demonstrate implementation of our 
// own hash table with chaining for collision detection 
#include<bits/stdc++.h>
using namespace std;

struct MyHash
{
    int BUCKET;
    list<int> *table;
    MyHash(int b)
    {
        BUCKET = b;
        table = new list<int>[BUCKET];
    }
    void insert(int k)
    {
        int i = k % BUCKET;
        table[i].push_back(k);
    }
    bool search(int k)
    {
        int i = k % BUCKET;
        for (auto x : table[i])
           if (x == k)
              return true;
        return false;      
    }
    void remove(int k)
    {
        int i = k % BUCKET;
        table[i].remove(k);
    }
};

	// Driver method to test Map class 
	int main() 
	{ 
	    MyHash mh(7);
	    mh.insert(10);
	    mh.insert(20);
	    mh.insert(15);
	    mh.insert(7);
	    cout << mh.search(10) << endl;
	    mh.remove(15);
	    cout << mh.search(15);
	} 
another way:
vector<vector<int>> separateChaining(int hashSize,int arr[],int sizeOfArray)
    {
       //Your code here
        vector<vector<int>> ans(hashSize);
       for(int i=0;i<sizeOfArray;i++){
           ans[arr[i]%hashSize].push_back(arr[i]);
       }
       return ans;
       
    }
    
    -------------------------------------------------------------------------------------------------------------------------------------------------------------
  OPEN ADDRESSING:
  
  No of slots in hash table >= no of keys to be inserted.
  Liner probing:
    Linearly search for next empty slot when there is a collision.
    
  Implementation of open addressing:
    
    #include<bits/stdc++.h>
using namespace std;

struct MyHash
{
    int *arr;
    int cap,size;
    
    MyHash(int c)
    {
        cap=c;
        size=0;
        arr=new int[cap];
        for(int i=0;i<cap;i++)
            arr[i]=-1;
    }
    
    int hash(int key){
        return key%cap;
    }
    bool insert(int key)
    {
        if(size==cap)
            return false;
        int i=hash(key);
        while(arr[i]!=-1 && arr[i]!=-2 && arr[i]!=key)
            i=(i+1)%cap;
        if(arr[i]==key)
            return false;
        else{
            arr[i]=key;
            size++;
            return true;
        }
    }
    bool search(int key)
    {
        int h=hash(key);
        int i=h;
        while(arr[i]!=-1){
            if(arr[i]==key)
                return true;
            i=(i+1)%cap;
            if(i==h)
                return false;
        }
        return false;
    }
    bool erase(int key)
    {   
        int h=hash(key);
        int i=h;
        while(arr[i]!=-1){
            if(arr[i]==key){
                arr[i]=-2;
                return true;
            }
            i=(i+1)%cap;
            if(i==h)
                return false;
        }
        return false;
    }
};

	int main() 
	{ 
	    MyHash mh(7);
	    mh.insert(49);
	    mh.insert(56);
	    mh.insert(72);
	    if(mh.search(56)==true)
	        cout<<"Yes"<<endl;
	    else
	        cout<<"No"<<endl;
	    mh.erase(56);
	    if(mh.search(56)==true)
	        cout<<"Yes"<<endl;
	    else
	        cout<<"No"<<endl;
	} 
----------------------------------------------------------------------------------------------------------------------------------------------------------------
UNORDERED SET IN STL: there cannot be duplicate keys in unordered set.

unlike set, unordered set has different functionalities. If we insert elements in unordered set, when we print the ouput the output sequences may differ in different compilers. There is no specific order in which these elements are stored in the unordered set.
Different functions of unordered set are:
insert() - insert an element into the set.
begin() - returns the iterator of first element
end()- return an ietrator beyond the end element.
size() - gives the size of the set
clear() - empties the set
find() - finds the element in the set. If present it return the address of that element. Else it return variableName.end().
count() - returns either 1 or 0 if elements is present or not. similar to find but it returns 1 or 0.
Erase() - used to remove a single item or range of items in the set.
all functions have O(1) time complexity in an average.
#include <bits/stdc++.h> 
using namespace std; 

int main(){
    
    unordered_set <int> s;
    s.insert(10);
    s.insert(5);
    s.insert(15);
    s.insert(20);
    for(int x: s)
        cout<<x<<" ";
        
    cout<<endl;
    for(auto it=s.begin();it!=s.end();it++)
        cout<<*it<<" ";
    cout<<endl;
    cout<<s.size()<<endl;
    s.clear();
    cout<<s.size()<<endl;
    
    s.insert(10);
    s.insert(5);
    s.insert(15);
    s.insert(20);
    cout<<s.size()<<endl;
    
    if(s.find(15)==s.end())
        cout<<"Not Found";
    else
        cout<<"Found "<<(*s.find(15));
    
    cout<<endl;   
    if(s.count(15))
        cout<<"Found";
    else
        cout<<"Not Found";
    cout<<endl;
    
    cout<<s.size()<<endl;
    s.erase(15);
    cout<<s.size()<<endl;
    auto it=s.find(10);
    s.erase(it);
    cout<<s.size()<<endl;
    
    s.erase(s.begin(),s.end());
        
    return 0;
}

--------------------------------------------------
UNORDERED HASHMAP IN STL:
-- used to store key value pairs.
-- uses hashing
-- no order of keys.

#include <bits/stdc++.h> 
using namespace std; 

int main(){
    
    unordered_map <string,int> m;
    m["gfg"]=20;
    m["ide"]=30;
    m.insert({"courses",15});
    
    if(m.find("ide")!=m.end())
        cout<<"Found";
    else
        cout<<"Not Found ";
    
    cout<<endl;
    
    for(auto it=m.begin();it!=m.end();it++)
        cout<<(it->first)<<" "<<(it->second)<<endl;
    
    if(m.count("ide")>0)
        cout<<"Found";
    else
        cout<<"Not Found";
    cout<<endl;
    
    cout<<m.size()<<endl;
    m.erase("ide");
    m.erase(m.begin());
    cout<<m.size()<<endl;
    m.erase(m.begin(),m.end());
        
    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------COUNT DISTNCT ELEMENTS:

int countDistinct(int arr[], int n)
{
    unordered_set<int> us;
    for(int i = 0; i < n; i++)
      us.insert(arr[i]);
      
    return us.size();
}

Another variation:
COUNT NON REPEATED ELEMENTS:
Hashing is very useful to keep track of the frequency of the elements in a list.

You are given an array of integers. You need to print the count of non-repeated elements in the array.

Example 1:

Input:
10
1 1 2 2 3 3 4 5 6 7

Output: 
4

Explanation: 
4, 5, 6 and 7 are the 
elements with frequency 1 and rest 
elements are repeated so the number 
of non-repeated elements are 4.

int countNonRepeated(int arr[], int n)
    {
        //Your code here
        unordered_set<int> set1;
        unordered_set<int> set2;
        for(int i=0;i<n;i++){
            if(set1.count(arr[i]) == 0)
            set1.insert(arr[i]);
            else if(set2.count(arr[i]) == 0)
            set2.insert(arr[i]);
        }
        return (set1.size()-set2.size());
    }
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Print Non-Repeated Elements:
Hashing is very useful to keep track of the frequency of the elements in a list.

You are given an array of integers. You need to print the non-repeated elements as they appear in the array.

Example 1:

Input:
n = 10
arr[] = {1,1,2,2,3,3,4,5,6,7}
Output: 4 5 6 7
Explanation: 4, 5, 6 and 7 are the only 
elements which is having only 1 
frequency and hence, Non-repeating.

vector<int> printNonRepeated(int arr[],int n)
    {
        //Your code here
        vector<int> res;
        unordered_map<int,int> s;
        for(int i=0;i<n;i++){
            s[arr[i]]++;
        }
        for(int i=0;i<n;i++){
            if(s[arr[i]] == 1)
            res.push_back(arr[i]);
        }
        return res;
        
    }
    
    -----------------------------------------------------------------------------------------------------------------------------------------------------------
    INTERSECTION OF TWO ARRAYS:
    
    Given two arrays a[] and b[] respectively of size n and m, the task is to print the count of elements in the intersection (or common elements) of the two arrays.

For this question, the intersection of two arrays can be defined as the set containing distinct common elements between the two arrays. 

Example 1:

Input:
n = 5, m = 3
a[] = {89, 24, 75, 11, 23}
b[] = {89, 2, 4}

Output: 1

Explanation: 
89 is the only element 
in the intersection of two arrays.
    
     int NumberofElementsInIntersection(int a[], int b[], int n, int m) {
        // Your code goes here
        unordered_set<int> res;
        int count = 0;
        for(int i=0;i<n;i++)
        res.insert(a[i]);
        for(int i=0;i<m;i++){
            if(res.count(b[i]) == 1)
            count++;
            res.erase(b[i]);
        }
        return count;
    }
    
   -----------------------------------------------------------------------------------------------------------------------------------------------------------------
   
UNION OF TWO UNSORTED ARRAYS:
int doUnion(int a[], int n, int b[], int m)  {
        //code here
        unordered_set<int> s;
        for(int i=0;i<n;i++)
            s.insert(a[i]);
        for(int j=0;j<m;j++)
        s.insert(b[j]);
        return s.size();
        
    }
    
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------
PAIR WITH GIVEN SUM IN UNSORTD ARRAY:
    
If the array is sorted then we can use two pointer pointer approach to solve the problem efficiently. But if the array is unsorted then we must use hashing technique to solve the problem.

The logic is to traverse through the array and if we find sum-arr[i] in the already traversed array and hashtable then we find the pair else insert the element in the hashtable.

I/P: 3,2,8,15,-8
SUM: 17
-- 17-3 = 14(there is nothing in the hashtable in 1st iteration so it simply inserts the element. HASHTABLE: 3
-- 17-2 = 15 (no 15 in hashtable, it inserts 2 in hashtable)  HASHTABLE: 3,2
-- 17-8 = 9 (no 9 in hashtable, it inserts 8 in hashtable)  HASHTABLE: 3,2,8
-- 17-15 = 2 (2 is present in the hashtable: 3,2,8 so we found the pair with given sum)

int pairWithSumX(int arr[],int n, int X)
{
    unordered_set<int> us;
    for(int i = 0; i < n; i++)
    {
        if(us.find(X - arr[i]) != us.end())
          return 1;
          
        us.insert(arr[i]);
    }
    return 0;
    
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

 SUB ARRAY WITH ZERO SUM: MUST BE CONTIGOUS ELEMENTS ONLY(the elements must present in continously).
 
 Here the logic is we mainatain a prefix sum variable which adds current elemets coninously and keeps checking it with hashtable if the prefix sum is already present in hashtable. If it is not present then we add that element to the hashtable else we return it if the prefix sum is present.
 
 I/P: -3,4,-3,-1,1
i = 0 presum: -3, does not present in hashtable so Hashtable: -3
i = 1 presum:-3+4 = 1 does not present in hashtable so hashtable: -3,1
i = 2 presum:1-3 = -2 does not present in hashtable so hashtable: -3,1,-2
i = 3 presum: -2-1 = -3 is already present in the hashtable: -3,1,-2 
so we return true

int ZeroSumSubarray(int arr[], int n)
{
    unordered_set<int> us;
    int prefix_sum = 0;
    us.insert(0);
    for(int i = 0; i < n; i++)
    {
        prefix_sum += arr[i];
        if(us.find(prefix_sum) != us.end())
          return 1;
        us.insert(prefix_sum);
    }
    return 0;
    
}
Time complexity: O(n).

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SUB ARRAY WITH GIVEN SUM:
 
 The approach is similar to the previous approach (sub array with zero sum), here we subtract with given sum and checks whether it is already present in the hashtable.
 we insert all presum elements in the hashtable first.
 I/P: 5,8,6,13,3,-1, sum = 22
 hashtable with presum: 5,13,19,32,35,34
 
 we have a corner case here if we dont write the line 
if(pre_sum==sum) // checks the corner case where 0th element+ ith element might result in the given sum.
            return true; 
	    eg: I/P: 1,2,4,7,  sum = 3
	      presum = 1,3,7,14
	      so when we are checking the above in the code we have
	      1-3 = -2
	      3-3 = 0
	      7-3 = 4
	      14-3 = 11 all are not present in the hashtable. But there is a sub array with given sum which is 2+1 the first two elements.
 
 then we go to each element in hashtable and keeps subtracting it with given sum, If we find the result present in the hashtable then we returns.
 
 
 
 bool isSum(int arr[], int n, int sum)
{
    unordered_set<int> s;
    int pre_sum = 0;
    for(int i = 0; i < n; i++)
    {   
        if(pre_sum==sum) // checks the corner case where 0th element+ ith element might result in the given sum.
            return true;
        pre_sum += arr[i];
        if(s.find(pre_sum-sum) != s.end())
          return true;
        s.insert(pre_sum);
    }
    return false;
}

Time complexity: O(n).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

PAIR WITH A GIVEN SUM IN AN ARRAY:
You are given an array of distinct integers and a sum. Check if there's a pair with the given sum in the array.

Example 1:

Input:
N = 10
arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 
sum = 14
Output: 
1

int sumExists(int arr[], int N, int sum) {
    // Your code here.
    unordered_set<int> s;
    for(int i=0;i<N;i++){
        if(s.find(sum-arr[i])!=s.end())
        return 1;
        else s.insert(arr[i]);
    }
    return 0;
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------




 
